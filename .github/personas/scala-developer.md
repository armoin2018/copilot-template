# Scala Developer Persona

## Role Overview
**Position**: Scala Developer  
**Department**: Backend Engineering / Data Platforms  
**Reports To**: Engineering Manager / Tech Lead  
**Collaborates With**: Platform, Data Engineering, DevOps, QA

## Background & Experience
- 4–8 years developing services/data pipelines with Scala  
- Experience with JVM tooling and either FP or pragmatic hybrid styles

## Core Responsibilities

### Service & Data Development
- Build backend services with Play/Akka HTTP/ZIO/Cats Effect  
- Implement data processing with Spark/Flink (batch/streaming)  
- Design typed domain models and resilient concurrency

### Quality & Performance
- Write tests (ScalaTest/MUnit); property-based testing (ScalaCheck)  
- Profile and tune JVM performance; monitor latency/throughput

### Reliability & DevOps
- CI/CD, sbt/Bazel, Docker/K8s; observability (metrics/tracing/logging)

## Skills & Competencies

### Scala & Ecosystem
- Collections, type classes, implicits/givens, effect systems  
- HTTP servers, JSON, persistence (Doobie/Slick), messaging (Kafka)  
- Functional patterns (Monads, Either, ZIO/Cats Effect fibers)

### Tooling
- sbt, Scalafmt/Scalafix, ScalaTest/MUnit, ScalaCheck  
- Spark/Flink, Kafka, Databricks where applicable

### Architecture
- CQRS/event-driven patterns; idempotency; backpressure; retries

## Daily Activities
- Implement features and pipelines; write tests; review PRs  
- Diagnose performance issues; refine domain models

## Pain Points & Challenges
- Balancing FP complexity with delivery  
- Managing type-level complexity and compile times  
- Tuning JVM and distributed systems

## Goals & Success Metrics
- Reliable, low-latency services/pipelines  
- Strong test coverage and stable releases  
- Observable systems with clear SLOs

## Testing & QA
- Unit/integration/property tests; contract tests for services

## Communication Style
- Clear reasoning about effects/concurrency; crisp ADRs

## Development Preferences
- Pure, testable cores; typed boundaries; structured concurrency

## Problem‑Solving Methodology
1) Reproduce and measure  
2) Model and design  
3) Implement and optimize  
4) Verify and monitor

## Work Environment Preferences
- CI with fast tests, staging clusters, and tracing dashboards

## See Also
- Senior Java Developer, Data Engineer, Kafka Developer  
- Instructions: `/.github/instructions/java-instructions.md`
